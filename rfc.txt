Title:

Runtime Channel Selection with Thread-Safe Configuration for Zephyr Comparator API.

Problem description:

The comparator peripheral compares analog signals from two input channels. Currently, Zephyr's comparator support uses fixed 
channel configurations defined in the device tree, which cannot be changed during runtime.

However, many SoCs actually support runtime channel selection through hardware multiplexing capabilities. While some 
comparator configurations like hysteresis, polarity, and reference voltage might be fixed, the input channel selection can 
often be modified dynamically.

The current Zephyr implementation doesn't expose this hardware capability, limiting developers to only using the channels
predefined in the device tree. This means even though the hardware supports switching between different input channels during operation,
the software API doesn't provide this flexibility.

This gap restricts the  applications from taking full advantage of the hardware's multiplexing features for dynamic signal comparison scenarios.

Proposal change(summary):

This proposal introduces runtime channel selection capability for Zephyr's comparator subsystem while ensuring thread 
safety through a comprehensive locking mechanism. The solution provides flexible channel selection for both single-ended
and differential modes with multi-thread protection.

Propasal change(detailed):

To add runtime channel selection support to the Zephyr comparator, I'm suggesting a new API:

```
int comparator_channel_select(const struct device *dev, uint8_t channel_id);
```
This function lets you choose which channel to use while in the runtime, working for both single-ended and differential modes.
The channel IDs can mapped (like e.g. (0-7) are for positive inputs and (8-15) are for negative inputs), as per the hardware-specification in the driver.

For differential mode, you'll call this API twice - once for the positive channel and once for the negative channel.

Since we're dealing with multiple threads that might try to change channels at the same time, I'm also adding thread-safe configuration locking:

```
int comparator_configuration_lock(const struct device *dev);
int comparator_configuration_unlock(const struct device *dev);
```
These lock/unlock functions prevent situations where one thread's channel selection gets overwritten by another thread.
When you lock the configuration, other threads won't be able to change the comparator settings until you unlock it.

This approach keeps things thread-safe while giving developers the flexibility to do runtime channel switching when they need it.


/**
 * @brief Select comparator channel at runtime
 *
 * @param dev Comparator device
 * @param channel_id Channel ID to select
 *
 * @retval 0 Successful
 * @retval -errno code Failure
 * @retval -ENOSYS If not implemented by driver
 */
__syscall int comparator_select_channel(const struct device *dev, uint8_t channel_id);

static inline int z_impl_comparator_select_channel(const struct device *dev, uint8_t channel_id)
{
	const struct comparator_driver_api *api =
		(const struct comparator_driver_api *)dev->api;
	
	if (api->select_channel == NULL) {
		return -ENOSYS;
	}

	return DEVICE_API_GET(comparator, dev)->select_channel(dev, channel_id);

}

/**
 * @brief Lock comparator for exclusive access
 *
 * @param dev Comparator device
 *
 * @retval 0 Successful
 * @retval -errno code Failure
 * @retval -ENOSYS If not implemented by driver
 *
 * @note Always pair with comparator_unlock()
 */
__syscall int comparator_configuration_lock(const struct device *dev);

static inline int z_impl_comparator_configuration_lock(const struct device *dev)
{
	const struct comparator_driver_api *api =
		(const struct comparator_driver_api *)dev->api;
	
	if (api->lock == NULL) {
		return -ENOSYS;
	}
	
        return DEVICE_API_GET(comparator, dev)->lock(dev);

}

/**
 * @brief Unlock comparator after exclusive access
 *
 * @param dev Comparator device
 *
 * @retval 0 Successful
 * @retval -errno code Failure
 * @retval -ENOSYS If not implemented by driver
 */
__syscall int comparator_configuration_unlock(const struct device *dev);

static inline int z_impl_comparator_configuration_unlock(const struct device *dev)
{
	const struct comparator_driver_api *api =
		(const struct comparator_driver_api *)dev->api;
	
	if (api->unlock == NULL) {
		return -ENOSYS;
	}
	
        return DEVICE_API_GET(comparator, dev)->unlock(dev);

}

APPROACH:
Approach using mutex member access:
this for the problem 1: (how lock and unlock protect the channel_setup or other configuration from other thread access)

mutex which is locked in one thread cannot be claimed by another thread(inside the lock api). So current thread only can unlock it.
For channel setup function, inside the k_mutex structure there is a member called owner which is used to store the identifier of
the thread which locked the mutex, which can be checked at the channel setup api (e.g. mutex.owner == k_current_get()) and sets up the channel.

Approach using lockcount:

As from the above, mutex which is locked by one thread cannot claimed by another thread. so in that lock function locks
the mutex and it will unlock only by calling the unlock function in the same thread. Between this inside the setup
function we can relock the mutex so the lock count will increase by 1 without blocking it(using K_NO_WAIT) this should be 
unlocked at the function itself (in the same thread). If another thread calls the setup function and it tries to re-lock 
the mutex in setup will fail. because this mutex owns by the another thread. It returns the errno.

Problem: 2 (Single parameter for channel selection is enough?) --It will conflict the single mode approach.

Another approaches:

Approach 1:

int comparator_channel_setup(const struct device *dev, uint8_t postive_channel_id, uint8_t negative_channel_id )
--Mark the unnessecary param as -1 based on the mode going to select.

Approach 2:

struct channel_cfg {
/*positive channel number*/
uint8_t positive_channel_id;

/*negative channel number*/
uint8_t negative_channel_id;

/* The flag may indicates the mode of the comparator
uint8_t flag;
};

int comparator_channel_setup( const struct device *dev, const struct channel_cfg *cfg)
(This approach is already requested by someone in comparator API introduction, Which was rejected at the time because he only asks for nrf. Now this applicable to all the vendors.
link:
https://github.com/zephyrproject-rtos/zephyr/pull/63094/files/cbc4050d39bda229273b8b0df384522e484bc7b7#diff-59f3e37905b4fd89638aa848bda993f3af7af4dc95febd76aae5311d46a87e3c

or
Approach 3:

int comparator_channel_setup( const struct device *dev, uint8_t positive_channel, uint8_t negative_channel, uint8_t flag);

positive_channel -- positive channel id
negative_channel -- negative channel id
flag			 -- Indicates the mode (single_pos, single_neg, differential)
